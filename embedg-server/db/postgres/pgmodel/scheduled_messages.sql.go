// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: scheduled_messages.sql

package pgmodel

import (
	"context"
	"database/sql"
	"time"
)

const deleteScheduledMessage = `-- name: DeleteScheduledMessage :exec
DELETE FROM scheduled_messages WHERE id = $1 AND guild_id = $2
`

type DeleteScheduledMessageParams struct {
	ID      string
	GuildID string
}

func (q *Queries) DeleteScheduledMessage(ctx context.Context, arg DeleteScheduledMessageParams) error {
	_, err := q.db.ExecContext(ctx, deleteScheduledMessage, arg.ID, arg.GuildID)
	return err
}

const getDueScheduledMessages = `-- name: GetDueScheduledMessages :many
SELECT id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name FROM scheduled_messages WHERE next_at <= $1 AND (end_at IS NULL OR end_at >= $1) AND enabled = true
`

func (q *Queries) GetDueScheduledMessages(ctx context.Context, nextAt time.Time) ([]ScheduledMessage, error) {
	rows, err := q.db.QueryContext(ctx, getDueScheduledMessages, nextAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledMessage
	for rows.Next() {
		var i ScheduledMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.SavedMessageID,
			&i.Name,
			&i.Description,
			&i.CronExpression,
			&i.OnlyOnce,
			&i.StartAt,
			&i.EndAt,
			&i.NextAt,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CronTimezone,
			&i.ThreadName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledMessage = `-- name: GetScheduledMessage :one
SELECT id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name FROM scheduled_messages WHERE id = $1 AND guild_id = $2
`

type GetScheduledMessageParams struct {
	ID      string
	GuildID string
}

func (q *Queries) GetScheduledMessage(ctx context.Context, arg GetScheduledMessageParams) (ScheduledMessage, error) {
	row := q.db.QueryRowContext(ctx, getScheduledMessage, arg.ID, arg.GuildID)
	var i ScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.GuildID,
		&i.ChannelID,
		&i.MessageID,
		&i.SavedMessageID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.OnlyOnce,
		&i.StartAt,
		&i.EndAt,
		&i.NextAt,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CronTimezone,
		&i.ThreadName,
	)
	return i, err
}

const getScheduledMessages = `-- name: GetScheduledMessages :many
SELECT id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name FROM scheduled_messages WHERE guild_id = $1 ORDER BY updated_at DESC
`

func (q *Queries) GetScheduledMessages(ctx context.Context, guildID string) ([]ScheduledMessage, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledMessages, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledMessage
	for rows.Next() {
		var i ScheduledMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.SavedMessageID,
			&i.Name,
			&i.Description,
			&i.CronExpression,
			&i.OnlyOnce,
			&i.StartAt,
			&i.EndAt,
			&i.NextAt,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CronTimezone,
			&i.ThreadName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertScheduledMessage = `-- name: InsertScheduledMessage :one
INSERT INTO scheduled_messages (
    id, 
    creator_id, 
    guild_id, 
    channel_id, 
    message_id, 
    thread_name, 
    saved_message_id, 
    name, 
    description, 
    cron_expression, 
    cron_timezone, 
    start_at, 
    end_at, 
    next_at, 
    only_once, 
    enabled, 
    created_at, 
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name
`

type InsertScheduledMessageParams struct {
	ID             string
	CreatorID      string
	GuildID        string
	ChannelID      string
	MessageID      sql.NullString
	ThreadName     sql.NullString
	SavedMessageID string
	Name           string
	Description    sql.NullString
	CronExpression sql.NullString
	CronTimezone   sql.NullString
	StartAt        time.Time
	EndAt          sql.NullTime
	NextAt         time.Time
	OnlyOnce       bool
	Enabled        bool
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) InsertScheduledMessage(ctx context.Context, arg InsertScheduledMessageParams) (ScheduledMessage, error) {
	row := q.db.QueryRowContext(ctx, insertScheduledMessage,
		arg.ID,
		arg.CreatorID,
		arg.GuildID,
		arg.ChannelID,
		arg.MessageID,
		arg.ThreadName,
		arg.SavedMessageID,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.CronTimezone,
		arg.StartAt,
		arg.EndAt,
		arg.NextAt,
		arg.OnlyOnce,
		arg.Enabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.GuildID,
		&i.ChannelID,
		&i.MessageID,
		&i.SavedMessageID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.OnlyOnce,
		&i.StartAt,
		&i.EndAt,
		&i.NextAt,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CronTimezone,
		&i.ThreadName,
	)
	return i, err
}

const updateScheduledMessage = `-- name: UpdateScheduledMessage :one
UPDATE scheduled_messages SET 
    channel_id = $3, 
    message_id = $4, 
    thread_name = $5, 
    saved_message_id = $6, 
    name = $7, 
    description = $8, 
    cron_expression = $9, 
    next_at = $10, 
    start_at = $11, 
    end_at = $12, 
    only_once = $13, 
    enabled = $14, 
    updated_at = $15, 
    cron_timezone = $16 
WHERE id = $1 AND guild_id = $2 RETURNING id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name
`

type UpdateScheduledMessageParams struct {
	ID             string
	GuildID        string
	ChannelID      string
	MessageID      sql.NullString
	ThreadName     sql.NullString
	SavedMessageID string
	Name           string
	Description    sql.NullString
	CronExpression sql.NullString
	NextAt         time.Time
	StartAt        time.Time
	EndAt          sql.NullTime
	OnlyOnce       bool
	Enabled        bool
	UpdatedAt      time.Time
	CronTimezone   sql.NullString
}

func (q *Queries) UpdateScheduledMessage(ctx context.Context, arg UpdateScheduledMessageParams) (ScheduledMessage, error) {
	row := q.db.QueryRowContext(ctx, updateScheduledMessage,
		arg.ID,
		arg.GuildID,
		arg.ChannelID,
		arg.MessageID,
		arg.ThreadName,
		arg.SavedMessageID,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.NextAt,
		arg.StartAt,
		arg.EndAt,
		arg.OnlyOnce,
		arg.Enabled,
		arg.UpdatedAt,
		arg.CronTimezone,
	)
	var i ScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.GuildID,
		&i.ChannelID,
		&i.MessageID,
		&i.SavedMessageID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.OnlyOnce,
		&i.StartAt,
		&i.EndAt,
		&i.NextAt,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CronTimezone,
		&i.ThreadName,
	)
	return i, err
}

const updateScheduledMessageEnabled = `-- name: UpdateScheduledMessageEnabled :one
UPDATE scheduled_messages SET enabled = $3, updated_at = $4 WHERE id = $1 AND guild_id = $2 RETURNING id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name
`

type UpdateScheduledMessageEnabledParams struct {
	ID        string
	GuildID   string
	Enabled   bool
	UpdatedAt time.Time
}

func (q *Queries) UpdateScheduledMessageEnabled(ctx context.Context, arg UpdateScheduledMessageEnabledParams) (ScheduledMessage, error) {
	row := q.db.QueryRowContext(ctx, updateScheduledMessageEnabled,
		arg.ID,
		arg.GuildID,
		arg.Enabled,
		arg.UpdatedAt,
	)
	var i ScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.GuildID,
		&i.ChannelID,
		&i.MessageID,
		&i.SavedMessageID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.OnlyOnce,
		&i.StartAt,
		&i.EndAt,
		&i.NextAt,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CronTimezone,
		&i.ThreadName,
	)
	return i, err
}

const updateScheduledMessageNextAt = `-- name: UpdateScheduledMessageNextAt :one
UPDATE scheduled_messages SET next_at = $3, updated_at = $4 WHERE id = $1 AND guild_id = $2 RETURNING id, creator_id, guild_id, channel_id, message_id, saved_message_id, name, description, cron_expression, only_once, start_at, end_at, next_at, enabled, created_at, updated_at, cron_timezone, thread_name
`

type UpdateScheduledMessageNextAtParams struct {
	ID        string
	GuildID   string
	NextAt    time.Time
	UpdatedAt time.Time
}

func (q *Queries) UpdateScheduledMessageNextAt(ctx context.Context, arg UpdateScheduledMessageNextAtParams) (ScheduledMessage, error) {
	row := q.db.QueryRowContext(ctx, updateScheduledMessageNextAt,
		arg.ID,
		arg.GuildID,
		arg.NextAt,
		arg.UpdatedAt,
	)
	var i ScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.GuildID,
		&i.ChannelID,
		&i.MessageID,
		&i.SavedMessageID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.OnlyOnce,
		&i.StartAt,
		&i.EndAt,
		&i.NextAt,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CronTimezone,
		&i.ThreadName,
	)
	return i, err
}
