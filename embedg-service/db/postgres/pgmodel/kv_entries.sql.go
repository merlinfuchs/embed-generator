// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: kv_entries.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countKVEntries = `-- name: CountKVEntries :one
SELECT COUNT(*) FROM kv_entries WHERE guild_id = $1
`

func (q *Queries) CountKVEntries(ctx context.Context, guildID string) (int64, error) {
	row := q.db.QueryRow(ctx, countKVEntries, guildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteKVEntry = `-- name: DeleteKVEntry :one
DELETE FROM kv_entries WHERE key = $1 AND guild_id = $2 RETURNING key, guild_id, value, expires_at, created_at, updated_at
`

type DeleteKVEntryParams struct {
	Key     string
	GuildID string
}

func (q *Queries) DeleteKVEntry(ctx context.Context, arg DeleteKVEntryParams) (KvEntry, error) {
	row := q.db.QueryRow(ctx, deleteKVEntry, arg.Key, arg.GuildID)
	var i KvEntry
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKVEntry = `-- name: GetKVEntry :one
SELECT key, guild_id, value, expires_at, created_at, updated_at FROM kv_entries WHERE key = $1 AND guild_id = $2
`

type GetKVEntryParams struct {
	Key     string
	GuildID string
}

func (q *Queries) GetKVEntry(ctx context.Context, arg GetKVEntryParams) (KvEntry, error) {
	row := q.db.QueryRow(ctx, getKVEntry, arg.Key, arg.GuildID)
	var i KvEntry
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const increaseKVEntry = `-- name: IncreaseKVEntry :one
INSERT INTO kv_entries (
    key, 
    guild_id, 
    value, 
    expires_at, 
    created_at, 
    updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
) ON CONFLICT (key, guild_id)
DO UPDATE SET 
    value = kv_entries.value::int + EXCLUDED.value::int, 
    expires_at = EXCLUDED.expires_at, 
    updated_at = EXCLUDED.updated_at
RETURNING key, guild_id, value, expires_at, created_at, updated_at
`

type IncreaseKVEntryParams struct {
	Key       string
	GuildID   string
	Value     string
	ExpiresAt pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) IncreaseKVEntry(ctx context.Context, arg IncreaseKVEntryParams) (KvEntry, error) {
	row := q.db.QueryRow(ctx, increaseKVEntry,
		arg.Key,
		arg.GuildID,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i KvEntry
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchKVEntries = `-- name: SearchKVEntries :many
SELECT key, guild_id, value, expires_at, created_at, updated_at FROM kv_entries WHERE key LIKE $1 AND guild_id = $2
`

type SearchKVEntriesParams struct {
	Key     string
	GuildID string
}

func (q *Queries) SearchKVEntries(ctx context.Context, arg SearchKVEntriesParams) ([]KvEntry, error) {
	rows, err := q.db.Query(ctx, searchKVEntries, arg.Key, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KvEntry
	for rows.Next() {
		var i KvEntry
		if err := rows.Scan(
			&i.Key,
			&i.GuildID,
			&i.Value,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setKVEntry = `-- name: SetKVEntry :exec
INSERT INTO kv_entries (
    key, 
    guild_id, 
    value, 
    expires_at, 
    created_at, 
    updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
) ON CONFLICT (key, guild_id) 
DO UPDATE SET 
    value = EXCLUDED.value, 
    expires_at = EXCLUDED.expires_at, 
    updated_at = EXCLUDED.updated_at
`

type SetKVEntryParams struct {
	Key       string
	GuildID   string
	Value     string
	ExpiresAt pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) SetKVEntry(ctx context.Context, arg SetKVEntryParams) error {
	_, err := q.db.Exec(ctx, setKVEntry,
		arg.Key,
		arg.GuildID,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
