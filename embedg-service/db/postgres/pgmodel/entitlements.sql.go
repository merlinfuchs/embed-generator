// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: entitlements.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveEntitlementsForGuild = `-- name: GetActiveEntitlementsForGuild :many
SELECT id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id FROM entitlements 
WHERE deleted = false 
  AND (starts_at IS NULL OR starts_at < NOW()) 
  AND (ends_at IS NULL OR ends_at > NOW()) 
  AND (guild_id = $1 OR consumed_guild_id = $1)
`

func (q *Queries) GetActiveEntitlementsForGuild(ctx context.Context, guildID pgtype.Text) ([]Entitlement, error) {
	rows, err := q.db.Query(ctx, getActiveEntitlementsForGuild, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entitlement
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GuildID,
			&i.UpdatedAt,
			&i.Deleted,
			&i.SkuID,
			&i.StartsAt,
			&i.EndsAt,
			&i.Consumed,
			&i.ConsumedGuildID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveEntitlementsForUser = `-- name: GetActiveEntitlementsForUser :many
SELECT id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id FROM entitlements 
WHERE deleted = false 
  AND (starts_at IS NULL OR starts_at < NOW()) 
  AND (ends_at IS NULL OR ends_at > NOW()) 
  AND user_id = $1
`

func (q *Queries) GetActiveEntitlementsForUser(ctx context.Context, userID pgtype.Text) ([]Entitlement, error) {
	rows, err := q.db.Query(ctx, getActiveEntitlementsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entitlement
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GuildID,
			&i.UpdatedAt,
			&i.Deleted,
			&i.SkuID,
			&i.StartsAt,
			&i.EndsAt,
			&i.Consumed,
			&i.ConsumedGuildID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitlement = `-- name: GetEntitlement :one
SELECT id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id FROM entitlements WHERE id = $1 AND user_id = $2
`

type GetEntitlementParams struct {
	ID     string
	UserID pgtype.Text
}

func (q *Queries) GetEntitlement(ctx context.Context, arg GetEntitlementParams) (Entitlement, error) {
	row := q.db.QueryRow(ctx, getEntitlement, arg.ID, arg.UserID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuildID,
		&i.UpdatedAt,
		&i.Deleted,
		&i.SkuID,
		&i.StartsAt,
		&i.EndsAt,
		&i.Consumed,
		&i.ConsumedGuildID,
	)
	return i, err
}

const getEntitlements = `-- name: GetEntitlements :many
SELECT id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id FROM entitlements
`

func (q *Queries) GetEntitlements(ctx context.Context) ([]Entitlement, error) {
	rows, err := q.db.Query(ctx, getEntitlements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entitlement
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GuildID,
			&i.UpdatedAt,
			&i.Deleted,
			&i.SkuID,
			&i.StartsAt,
			&i.EndsAt,
			&i.Consumed,
			&i.ConsumedGuildID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntitlementConsumedGuildID = `-- name: UpdateEntitlementConsumedGuildID :one
UPDATE entitlements SET consumed = true, consumed_guild_id = $2 WHERE id = $1 RETURNING id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id
`

type UpdateEntitlementConsumedGuildIDParams struct {
	ID              string
	ConsumedGuildID pgtype.Text
}

func (q *Queries) UpdateEntitlementConsumedGuildID(ctx context.Context, arg UpdateEntitlementConsumedGuildIDParams) (Entitlement, error) {
	row := q.db.QueryRow(ctx, updateEntitlementConsumedGuildID, arg.ID, arg.ConsumedGuildID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuildID,
		&i.UpdatedAt,
		&i.Deleted,
		&i.SkuID,
		&i.StartsAt,
		&i.EndsAt,
		&i.Consumed,
		&i.ConsumedGuildID,
	)
	return i, err
}

const upsertEntitlement = `-- name: UpsertEntitlement :one
INSERT INTO entitlements (
  id,
  user_id,
  guild_id,
  updated_at,
  deleted,
  sku_id,
  starts_at,
  ends_at,
  consumed
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
) 
ON CONFLICT (id) 
DO UPDATE SET 
  deleted = $5, 
  starts_at = $7, 
  ends_at = $8, 
  updated_at = $4, 
  consumed = $9
RETURNING id, user_id, guild_id, updated_at, deleted, sku_id, starts_at, ends_at, consumed, consumed_guild_id
`

type UpsertEntitlementParams struct {
	ID        string
	UserID    pgtype.Text
	GuildID   pgtype.Text
	UpdatedAt pgtype.Timestamp
	Deleted   bool
	SkuID     string
	StartsAt  pgtype.Timestamp
	EndsAt    pgtype.Timestamp
	Consumed  bool
}

func (q *Queries) UpsertEntitlement(ctx context.Context, arg UpsertEntitlementParams) (Entitlement, error) {
	row := q.db.QueryRow(ctx, upsertEntitlement,
		arg.ID,
		arg.UserID,
		arg.GuildID,
		arg.UpdatedAt,
		arg.Deleted,
		arg.SkuID,
		arg.StartsAt,
		arg.EndsAt,
		arg.Consumed,
	)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuildID,
		&i.UpdatedAt,
		&i.Deleted,
		&i.SkuID,
		&i.StartsAt,
		&i.EndsAt,
		&i.Consumed,
		&i.ConsumedGuildID,
	)
	return i, err
}
